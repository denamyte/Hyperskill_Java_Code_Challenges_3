<h2>Binary heap in Java</h2>
<html>
 <head></head>
 <body>
  <p><strong>Binary heap</strong> is a binary tree for which the following properties hold:</p> 
  <ul> 
   <li>values of children are not smaller than the value of a parent node (min-heap);</li> 
   <li>the difference between the maximum and the minimum depths of leaves is no greater than 1;</li> 
   <li>the tree is complete.</li> 
  </ul> 
  <p>The figure below is an example of a min-heap:</p> 
  <p style="text-align: center;"><img alt="" height="339" src="https://ucarecdn.com/fff19356-7f02-4b34-8312-3eb4fe7a42dd/" width="459"></p> 
  <p>In this topic, we will consider how this data structure can be implemented in Java.</p> 
  <h5 style="text-align: center;">Implementation in Java</h5> 
  <p>As you remember, there is a convenient way of storing binary trees in <strong>arrays</strong>, where children of the node $i$ will be nodes numbered <span class="math-tex">\(2i\)</span> and <span class="math-tex">\(2i+1\)</span>. Because the tree is complete, it is safe to say that the array will have no empty spaces and its size will be proportional to the size of the heap, which is very good in terms of memory management.</p> 
  <p>Take a look at the main class for min-heap implementation:</p> 
  <pre><code class="language-java">public class MinHeap {
    private int[] heap;
    private int size;
    private int maxsize;

    public MinHeap(int maxsize) {
        this.maxsize = maxsize;
        this.size = 0;
        heap = new int[this.maxsize + 1];
        heap[0] = Integer.MIN_VALUE;
    }

    private void swap(int fpos, int spos) {
        int tmp;
        tmp = heap[fpos];
        heap[fpos] = heap[spos];
        heap[spos] = tmp;
    }

    private void minHeapify(int pos) {
        if (2 * pos == size) {
            if (heap[pos] &gt; heap[2 * pos]) {
                swap(pos, 2 * pos);
                minHeapify(2 * pos);
            }
            return;
        }

        if (2 * pos &lt;= size) {
            if (heap[pos] &gt; heap[2 * pos] || heap[pos] &gt; heap[2 * pos + 1]) {
                if (heap[2 * pos] &lt; heap[2 * pos + 1]) {
                    swap(pos, 2 * pos);
                    minHeapify(2 * pos);
                }
                else {
                    swap(pos, 2 * pos + 1);
                    minHeapify(2 * pos + 1);
                }
            }
        }
    }

    public void insert(int element) {
        heap[++size] = element;
        int current = size;

        while (heap[current] &lt; heap[current / 2]) {
            swap(current, current / 2);
            current = current / 2;
        }
    }

    public void minHeap() {
        for (int pos = (size / 2); pos &gt;= 1; pos--) {
            minHeapify(pos);
        }
    }

    public int extractMin() {
        if (size == 0) {
            throw new NoSuchElementException("Heap is empty");
        }
        int popped = heap[1];
        heap[1] = heap[size--];
        minHeapify(1);
        return popped;
    }
}</code></pre> 
  <p>Let’s discuss its basic components:</p> 
  <p>- <code class="language-java">int[] heap</code> – the main array containing the elements of the heap;</p> 
  <p>- <code class="language-java">int size, maxsize</code> – current and max sizes of the heap;</p> 
  <p>- <code class="language-java">void swap(a, b)</code> – a helper method that swaps two values at indexes <code class="language-java">a</code> and <code class="language-java">b</code>;</p> 
  <p>- <code class="language-java">void insert(elem)</code> – a method for adding the new <code class="language-java">elem</code> value to the heap;</p> 
  <p>- <code class="language-java">int extractMin()</code> – extracts the minimum value which is located in the root from the min-heap and balances the tree;</p> 
  <p>- <code class="language-java">void minHeapify(pos)</code> – pushes the value at the <code class="language-java">pos</code> position to its proper place. This method is required when we remove the minimum element with <em>extractMin()</em>, replacing it with an element from the bottom then shifting it down to its required place. During the addition operation, we conversely lift the element from the bottom to where it should be, so this operation doesn’t need a helper method, unlike <em>extractMin()</em>;</p> 
  <p>- <code class="language-java">void minHeap()</code> – a method which transforms an arbitrary array into a min-heap in place. In other words, it is equivalent to several uses of <code class="language-java">insert(elem)</code>, only more elegant. The usage of methods for creating a heap should be obvious: in the first case, we already have all the elements, and in the second case, we are told which nodes to add one by one. Please note that you should opt for <code class="language-java">minheap()</code> method where you can: it has <span class="math-tex">\(O(n)\)</span> asymptote for all elements altogether, while <code class="language-java">insert(elem)</code> has <span class="math-tex">\(O(\log n)\)</span> for each element, which is slower.</p> 
  <p>You have probably noticed that the zeroth element of the <code class="language-java">heap</code> array is initialized with the smallest integer. This is done in order to ensure that surfacing of the number during addition will eventually finish, since <code class="language-java">while (heap[current]&lt;heap[current / 2])</code> will stop when <code class="language-java">heap[current / 2]</code> becomes the smallest integer.</p> 
  <h5>Usage examples</h5> 
  <p>Now it's time to learn how to use the class:</p> 
  <pre><code class="language-java">MinHeap minHeap = new MinHeap(15);
minHeap.insert(5);
minHeap.insert(45);
minHeap.insert(83);
minHeap.insert(23);
minHeap.insert(34);
minHeap.insert(71);
minHeap.insert(36);
minHeap.insert(10);
minHeap.insert(13);
out.println(minHeap.extractMin()); // 5
out.println(minHeap.extractMin()); // 10
minHeap.insert(4);
out.println(minHeap.extractMin()); // 4
out.println(minHeap.extractMin()); // 13</code></pre> 
  <p>At first, we initialize the heap, knowing in advance that its size will not be greater than 15. Then we add elements 5, 45, 83, 23, 34, 71, 36, 10 and 13. After that we extract two minimum values, which are clearly 5 and 10. Next, we add 4 to the heap and it becomes the minimum element. Finally, we call the "extract Min" method twice, and it returns 4 and 13 respectively. Both addition and minimum extraction operations work in <span class="math-tex">\(O(\log n)\)</span>.</p> 
  <h5 style="text-align: center;">Heapsort</h5> 
  <p>We will try to code this sort (which we discussed in theory) during this lesson. In fact, we already have minHeap() method that transforms an array into a min-heap, and we simply need to call extractMin() <em>n</em> times to get a sorted array. We won't describe the full code of heapsort here: you will receive a task for that later, and theoretical description given earlier should suffice. To remind you, the resulting algorithm will have <span class="math-tex">\(O(n)+O(n \log n)=O(n \log n)\)</span> time complexity and <span class="math-tex">\(O(n)\)</span> memory complexity. The latter is achieved by algorithm working in place: no extra memory is required.</p> 
  <h5 style="text-align: center;">Conclusion</h5> 
  <p>In this lesson, we examined how binary heaps work and considered the main operations, time complexity and heapsort. But there is a catch: Java has <code class="language-java">PriorityQueue</code>, an innate binary heap that can work with arbitrary data types. In most cases, this binary heap implementation is enough, but you should know its structure anyway: you might need to modify the algorithm which you cannot do with PriorityQueue. During the next exercises you will get an opportunity to write your own PriorityQueue.</p>
 </body>
</html>
